### JPQL이 영속성 컨텍스트의 1차 캐시를 먼저 검사하지 않고 바로 쿼리를 수행하는 이유

범위 및 복잡성: JPQL 쿼리는 데이터베이스에서 매우 복잡한 쿼리를 실행할 수 있으며, 여러 테이블 간의 조인, 그룹화, 
정렬 등 다양한 조작을 수행할 수 있습니다. 이러한 복잡한 쿼리를 1차 캐시에서 수행하는 것은 비효율적이고 성능에 부정적인 영향을 미칠 수 있습니다.

캐시 크기: 영속성 컨텍스트의 1차 캐시는 일반적으로 메모리에 저장되며,
큰 데이터셋을 처리하는 경우 메모리 부족 문제가 발생할 수 있습니다. 따라서 JPQL 쿼리는 데이터베이스에서 직접 결과를 가져오는 것이 더 효율적입니다.

데이터 신뢰성: 데이터베이스에서 직접 쿼리를 수행하면 항상 최신 상태의 데이터를 가져올 수 있습니다. 
반면 1차 캐시는 영속성 컨텍스트가 유지되는 동안만 변경을 추적하므로, 여러 트랜잭션 간의 일관성을 보장하기 어렵습니다. 
JPQL이 데이터베이스에서 직접 데이터를 가져오면, 다른 사용자나 시스템에 의한 변경 사항을 반영한 결과를 얻을 수 있습니다.

성능 최적화: 데이터베이스는 쿼리 처리를 위한 최적화 기능을 제공하며, 인덱싱, 쿼리 플랜 최적화 등을 사용하여 높은 성능을 보장합니다. 
반면 1차 캐시에서 직접 쿼리를 수행하는 것은 이러한 최적화를 활용할 수 없습니다.

그러나 JPQL 쿼리의 결과로 반환된 엔티티들은 영속성 컨텍스트에서 관리되고, 이미 1차 캐시에 존재하는 엔티티 인스턴스와 동일한 경우 해당 인스턴스를 재사용합니다. 
이렇게 함으로써 일부 성능 이점과 데이터 일관성을 얻을 수 있습니다.
